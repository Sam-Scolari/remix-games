<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Burger Stacking Game</title>
    <style>
      body {
        margin: 0;
        background: #f0e4cc;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        background: #cbe7ea;
        touch-action: none;
        cursor: pointer;
      }
      #score {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 24px;
        font-family: Arial, sans-serif;
        color: #ffffff;
      }
      #lives {
        position: absolute;
        top: 20px;
        right: 20px;
        font-size: 24px;
        font-family: Arial, sans-serif;
        color: #ffffff;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>
    <div id="lives">Lives: 3</div>
    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
    <script>
      (function () {
        const { Engine, Render, Runner, Bodies, Composite, Body, Events, Vertices } = Matter;
        const canvas = document.getElementById("gameCanvas");
        const scoreElement = document.getElementById("score");
        const livesElement = document.getElementById("lives");
        let score = 0;
        let lives = 3;
        let cw = Math.min(window.innerWidth, 500);
        let ch = Math.min(window.innerHeight, 900);
        canvas.width = cw;
        canvas.height = ch;

        const engine = Engine.create();
        const world = engine.world;
        world.gravity.y = 1;

        const render = Render.create({
          canvas: canvas,
          engine: engine,
          options: { width: cw, height: ch, wireframes: false },
        });
        Render.run(render);
        Runner.run(Runner.create(), engine);

        // Plate dimensions and fixed Y
        const plateWidth = cw * 0.5;
        let plateY = ch - 60;

        const plate = Bodies.rectangle(cw / 2, plateY, plateWidth, 20, {
          isStatic: true,
          label: "plate",
          friction: 0.8,
          render: { fillStyle: "#ffffff" },
        });
        Composite.add(world, plate);

        let gameOver = false;
        const gameOverElement = document.createElement('div');
        gameOverElement.style.position = 'absolute';
        gameOverElement.style.top = '50%';
        gameOverElement.style.left = '50%';
        gameOverElement.style.transform = 'translate(-50%, -50%)';
        gameOverElement.style.fontSize = '48px';
        gameOverElement.style.fontFamily = 'Arial, sans-serif';
        gameOverElement.style.color = '#ff0000';
        gameOverElement.style.display = 'none';
        gameOverElement.textContent = 'GAME OVER!';
        document.body.appendChild(gameOverElement);

        // Check for game over in the update loop
        Events.on(engine, "afterUpdate", () => {
          if (gameOver) return;
          
          Body.setPosition(plate, { x: plate.position.x, y: plateY });
          Body.setVelocity(plate, { x: plate.velocity.x, y: 0 });
          Body.setAngle(plate, 0);
          Body.setAngularVelocity(plate, 0);

          // Check if any ingredient has fallen off
          Composite.allBodies(world).forEach(body => {
            if (body.label === "ingredient") {
              // Check if ingredient has reached the bottom of the screen
              if (body.position.y > ch - 20) {
                lives--;
                livesElement.textContent = `Lives: ${lives}`;
                
                // Remove the fallen ingredient
                Composite.remove(world, body);
                
                if (lives <= 0) {
                  gameOver = true;
                  gameOverElement.style.display = 'block';
                  // Stop spawning new ingredients
                  clearInterval(spawnInterval);
                }
              }
            }
          });
        });

        const sequence = [
          { w: 150, h: 30, mass: 2, color: "#d2691e" }, // bottom bun
          { w: 130, h: 20, mass: 3, color: "#8b4513" }, // patty
          { w: 140, h: 15, mass: 1, color: "#7cfc00" }, // lettuce
          { w: 120, h: 15, mass: 1.5, color: "#ff6347" }, // tomato
          { w: 130, h: 10, mass: 1, color: "#ffd700" }, // cheese
          { w: 150, h: 30, mass: 2, color: "#d2691e" }, // top bun
        ];
        let index = 0;
        let currentBody = null;

        function spawnIngredient() {
          const def = sequence[index % sequence.length];
          index++;
          score++;
          scoreElement.textContent = `Score: ${score}`;
          
          // Calculate random x position within screen bounds
          const minVisible = plateWidth * 0.2;
          const minX = minVisible;
          const maxX = cw - minVisible;
          const randomX = minX + Math.random() * (maxX - minX);
          
          const body = Bodies.rectangle(randomX, -def.h, def.w, def.h, {
            label: "ingredient",
            mass: def.mass,
            friction: 0.3,
            restitution: 0.1,
            frictionAir: 0.02,
            render: { fillStyle: def.color },
          });
          Composite.add(world, body);
          return body;
        }

        currentBody = spawnIngredient();

        // Spawn new ingredients every 1.5 seconds
        const spawnInterval = setInterval(() => {
          spawnIngredient();
        }, 1500);

        // Remove the collision handler since we're spawning continuously
        Events.on(engine, "collisionStart", (event) => {
          // Collision handling removed since we're spawning continuously
        });

        // Mouse drag only adjusts X position, plate Y never changes
        let isDragging = false;
        let dragOffset = 0;
        canvas.addEventListener("mousedown", (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          if (Vertices.contains(plate.vertices, { x, y })) {
            isDragging = true;
            dragOffset = x - plate.position.x;
          }
        });
        canvas.addEventListener("mousemove", (e) => {
          if (isDragging) {
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left - dragOffset;
            // Allow plate to go partially offscreen (keep 20% visible)
            const minVisible = plateWidth * 0.2;
            x = Math.max(-plateWidth + minVisible, Math.min(cw - minVisible, x));
            
            // Calculate how far the plate moved
            const deltaX = x - plate.position.x;
            
            // Find all ingredients connected to the plate
            const connectedBodies = new Set();
            const toCheck = [plate];
            
            while (toCheck.length > 0) {
              const current = toCheck.pop();
              
              // Check all ingredients
              Composite.allBodies(world).forEach(body => {
                if (body.label === "ingredient" && !connectedBodies.has(body)) {
                  // Check if ingredient is near the current body
                  const distance = Math.sqrt(
                    Math.pow(body.position.x - current.position.x, 2) +
                    Math.pow(body.position.y - current.position.y, 2)
                  );
                  const maxDistance = Math.max(body.bounds.max.x - body.bounds.min.x, 
                                            body.bounds.max.y - body.bounds.min.y);
                  
                  if (distance < maxDistance) {
                    connectedBodies.add(body);
                    toCheck.push(body);
                  }
                }
              });
            }
            
            // Move all connected ingredients
            connectedBodies.forEach(body => {
              Body.setPosition(body, {
                x: body.position.x + deltaX,
                y: body.position.y
              });
            });
            
            Body.setPosition(plate, { x: x, y: plateY });
          }
        });
        ["mouseup", "mouseleave"].forEach((evt) =>
          canvas.addEventListener(evt, () => {
            isDragging = false;
          }),
        );

        // Handle resize
        window.addEventListener("resize", () => {
          cw = Math.min(window.innerWidth, 500);
          ch = Math.min(window.innerHeight, 900);
          canvas.width = cw;
          canvas.height = ch;
          render.canvas.width = cw;
          render.canvas.height = ch;
          plateY = ch - 60;
          Body.setPosition(plate, { x: cw / 2, y: plateY });
        });
      })();
    </script>
  </body>
</html>

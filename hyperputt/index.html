<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperputt - Mini Golf</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #2c5530;
            overflow: hidden;
            font-family: Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #gameCanvas {
            display: block;
            background: #4a7c59;
            cursor: crosshair;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 100;
        }



        #powerBar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 20px;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }

        #powerFill {
            width: 100%;
            background: linear-gradient(180deg, #ff6b6b, #ff8e53, #ffd93d);
            height: 0%;
            transition: height 0.1s ease;
            position: absolute;
            bottom: 0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>Strokes: <span id="strokeCount">0</span></div>
        <div>Level: <span id="levelCount">1</span></div>
    </div>
    <div id="powerBar">
        <div id="powerFill"></div>
    </div>


    <script>
        class Hyperputt {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.strokeCountElement = document.getElementById('strokeCount');
                this.levelCountElement = document.getElementById('levelCount');
                this.powerFillElement = document.getElementById('powerFill');
                
                this.lastTime = 0;
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.dragEnd = { x: 0, y: 0 };
                this.power = 0;
                this.maxPower = 800;
                
                // Initialize ball and hole with default positions
                // Viewport settings
                this.viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    x: 0,
                    y: 0
                };
                
                // World settings will be set by level generator later
                this.cellSize = 100;
                
                // Resize canvas first
                this.resizeCanvas();
                
                // Generate first level
                this.generateLevel();
                
                // Initialize stroke & level counters
                this.strokes = 0;
                this.level = 1;
                
                window.addEventListener('resize', () => this.resizeCanvas());
                this.setupEventListeners();
                this.gameLoop();
                

            }
            
                        resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Update viewport size only (do not reset ball/hole)
                this.viewport.width = window.innerWidth;
                this.viewport.height = window.innerHeight;
            }
            
            generateLevel() {
                // Dynamic world size based on viewport so it is always larger than screen
                const minCols = Math.ceil(this.viewport.width / this.cellSize) + 4;
                const minRows = Math.ceil(this.viewport.height / this.cellSize) + 2;
                const cols = Math.max(14, minCols);
                const rows = Math.max(10, minRows);

                // Start and end rows
                const startRow = Math.floor(Math.random() * rows);
                const endRow = Math.floor(Math.random() * rows);

                // 0 = wall, 1 = floor
                const grid = Array.from({ length: rows }, () => Array(cols).fill(0));

                // ----- BFS shortest path carve -----
                const queue = [];
                const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
                const parent = Array.from({ length: rows }, () => Array(cols).fill(null));

                queue.push([startRow, 0]);
                visited[startRow][0] = true;
                const dirs = [
                    [1, 0], // down
                    [-1, 0], // up
                    [0, 1], // right
                    [0, -1] // left
                ];

                while (queue.length) {
                    const [r, c] = queue.shift();
                    if (r === endRow && c === cols - 1) break; // reached goal
                    dirs.forEach(([dr, dc]) => {
                        const nr = r + dr;
                        const nc = c + dc;
                        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {
                            visited[nr][nc] = true;
                            parent[nr][nc] = [r, c];
                            queue.push([nr, nc]);
                        }
                    });
                }

                // Reconstruct path from end to start
                let path = [];
                let cur = [endRow, cols - 1];
                while (cur) {
                    const [r, c] = cur;
                    path.push(cur);
                    cur = parent[r][c];
                }
                path = path.reverse();

                // Helper to carve a 3x3 (radius 1) area around a cell
                const carveCell = (r, c, radius = 1) => {
                    for (let dr = -radius; dr <= radius; dr++) {
                        for (let dc = -radius; dc <= radius; dc++) {
                            const rr = r + dr;
                            const cc = c + dc;
                            if (rr >= 0 && rr < rows && cc >= 0 && cc < cols) {
                                grid[rr][cc] = 1;
                            }
                        }
                    }
                };

                // Carve the guaranteed path with width 3x3
                path.forEach(([r, c]) => carveCell(r, c, 1));

                // Extra clearing around hole (radius 2)
                carveCell(endRow, cols - 1, 2);

                // ----- Optional extra rooms / openness -----
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (grid[r][c] === 1) {
                            const neighbors = [
                                [r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]
                            ];
                            neighbors.forEach(([nr, nc]) => {
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && Math.random() < 0.2) {
                                    grid[nr][nc] = 1;
                                }
                            });
                        }
                    }
                }

                // ---------- Prune narrow dead-end open tiles (>=3 adjacent walls) ----------
                const protectedSet = new Set(path.map(([r, c]) => `${r},${c}`));
                let changed = true;
                while (changed) {
                    changed = false;
                    const toFill = [];
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            if (grid[r][c] !== 1) continue;
                            if (protectedSet.has(`${r},${c}`)) continue; // never fill main path
                            let wallsAdj = 0;
                            if (r === 0 || grid[r - 1][c] === 0) wallsAdj++;
                            if (r === rows - 1 || grid[r + 1][c] === 0) wallsAdj++;
                            if (c === 0 || grid[r][c - 1] === 0) wallsAdj++;
                            if (c === cols - 1 || grid[r][c + 1] === 0) wallsAdj++;
                            if (wallsAdj >= 3) toFill.push([r, c]);
                        }
                    }
                    if (toFill.length) {
                        changed = true;
                        toFill.forEach(([r, c]) => (grid[r][c] = 0));
                    }
                }

                // Save grid & compute walls array
                this.grid = grid;
                // Build edge list from grid floor-to-wall transitions
                this.edges = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (grid[r][c] !== 1) continue;
                        const x = c * this.cellSize;
                        const y = r * this.cellSize;
                        // top edge
                        if (r === 0 || grid[r - 1][c] === 0) {
                            this.edges.push({ x1: x, y1: y, x2: x + this.cellSize, y2: y, horizontal: true });
                        }
                        // bottom edge
                        if (r === rows - 1 || grid[r + 1][c] === 0) {
                            this.edges.push({ x1: x, y1: y + this.cellSize, x2: x + this.cellSize, y2: y + this.cellSize, horizontal: true });
                        }
                        // left edge
                        if (c === 0 || grid[r][c - 1] === 0) {
                            this.edges.push({ x1: x, y1: y, x2: x, y2: y + this.cellSize, horizontal: false });
                        }
                        // right edge
                        if (c === cols - 1 || grid[r][c + 1] === 0) {
                            this.edges.push({ x1: x + this.cellSize, y1: y, x2: x + this.cellSize, y2: y + this.cellSize, horizontal: false });
                        }
                    }
                }
                // Walls array no longer needed for collision; keep for legacy draw if desired
                this.walls = [];

                // World dimensions
                this.worldWidth = cols * this.cellSize;
                this.worldHeight = rows * this.cellSize;

                // Place ball at start
                this.ball = {
                    x: this.cellSize / 2,
                    y: startRow * this.cellSize + this.cellSize / 2,
                    radius: 15,
                    vx: 0,
                    vy: 0,
                    friction: 0.98
                };

                // Place hole
                this.hole = {
                    x: (cols - 0.5) * this.cellSize,
                    y: endRow * this.cellSize + this.cellSize / 2,
                    radius: 25
                };

                // Obstacles – only in floor cells that are NOT on the carved path (keep distance)
                this.obstacles = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (grid[r][c] === 1 && !protectedSet.has(`${r},${c}`) && Math.random() < 0.03) {
                            const ox = c * this.cellSize + this.cellSize / 2;
                            const oy = r * this.cellSize + this.cellSize / 2;
                            const bDist = Math.hypot(ox - this.ball.x, oy - this.ball.y);
                            const hDist = Math.hypot(ox - this.hole.x, oy - this.hole.y);
                            if (bDist > 250 && hDist > 300) {
                                this.obstacles.push({ x: ox, y: oy, radius: 20 + Math.random() * 15 });
                            }
                        }
                    }
                }
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                
                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleMouseDown(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleMouseMove(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleMouseUp(e);
                });
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                // Convert screen coordinates to world coordinates
                const worldX = screenX + this.viewport.x;
                const worldY = screenY + this.viewport.y;
                
                // Check if clicking on the ball
                const dx = worldX - this.ball.x;
                const dy = worldY - this.ball.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= this.ball.radius && this.ball.vx === 0 && this.ball.vy === 0) {
                    this.isDragging = true;
                    this.dragStart = { x: worldX, y: worldY };
                    this.dragEnd = { x: worldX, y: worldY };
                }
            }
            
            handleMouseMove(e) {
                if (!this.isDragging) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                let worldX = screenX + this.viewport.x;
                let worldY = screenY + this.viewport.y;
                
                // Clamp drag end so distance doesn't exceed max power distance
                const dx0 = worldX - this.dragStart.x;
                const dy0 = worldY - this.dragStart.y;
                const dist0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);
                const maxDrag = this.maxPower / 4; // because power = distance*4
                if (dist0 > maxDrag) {
                    const f = maxDrag / dist0;
                    worldX = this.dragStart.x + dx0 * f;
                    worldY = this.dragStart.y + dy0 * f;
                }
                this.dragEnd = { x: worldX, y: worldY };

                // Calculate power based on (possibly clamped) drag distance
                const dx = this.dragStart.x - this.dragEnd.x;
                const dy = this.dragStart.y - this.dragEnd.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.power = Math.min(distance * 4, this.maxPower);
                
                // Update power bar
                const powerPercent = (this.power / this.maxPower) * 100;
                this.powerFillElement.style.height = powerPercent + '%';
            }
            
            handleMouseUp(e) {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                
                // Calculate velocity based on drag direction and power
                const dx = this.dragStart.x - this.dragEnd.x;
                const dy = this.dragStart.y - this.dragEnd.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 10) {
                    this.ball.vx = (dx / distance) * (this.power / 10);
                    this.ball.vy = (dy / distance) * (this.power / 10);
                    this.strokes++;
                    this.strokeCountElement.textContent = this.strokes;
                }
                
                this.power = 0;
                this.powerFillElement.style.height = '0%';
            }
            
            update(deltaTime) {
                // Substep simulation to prevent tunnelling
                const timeScale = deltaTime / 16.67; // relative to 60 FPS tick
                const maxMove = Math.max(Math.abs(this.ball.vx), Math.abs(this.ball.vy)) * timeScale;
                const stepSize = this.ball.radius / 2; // move at most half-radius per substep
                const steps = Math.max(1, Math.ceil(maxMove / stepSize));

                for (let i = 0; i < steps; i++) {
                    const subFactor = timeScale / steps;
                    this.ball.x += this.ball.vx * subFactor;
                    this.ball.y += this.ball.vy * subFactor;
                }
                
                // Apply friction
                this.ball.vx *= this.ball.friction;
                this.ball.vy *= this.ball.friction;
                
                // Stop ball if velocity is very low
                if (Math.abs(this.ball.vx) < 0.1) this.ball.vx = 0;
                if (Math.abs(this.ball.vy) < 0.1) this.ball.vy = 0;
                
                // Ball collision with edge segments
                this.edges.forEach(edge => {
                    const outlineHalf = 4; // half of 8px perimeter stroke width
                    if (edge.horizontal) {
                        // horizontal line y = constant from x1 to x2
                        const minX = Math.min(edge.x1, edge.x2);
                        const maxX = Math.max(edge.x1, edge.x2);
                        const dy = this.ball.y - edge.y1;
                        if (Math.abs(dy) < this.ball.radius + outlineHalf && this.ball.x >= minX && this.ball.x <= maxX) {
                            const overlap = this.ball.radius + outlineHalf - Math.abs(dy);
                            const sign = dy > 0 ? 1 : -1;
                            this.ball.y += overlap * sign;
                            this.ball.vy *= -0.8;
                        }
                    } else {
                        // vertical line x = constant
                        const minY = Math.min(edge.y1, edge.y2);
                        const maxY = Math.max(edge.y1, edge.y2);
                        const dx = this.ball.x - edge.x1;
                        if (Math.abs(dx) < this.ball.radius + outlineHalf && this.ball.y >= minY && this.ball.y <= maxY) {
                            const overlap = this.ball.radius + outlineHalf - Math.abs(dx);
                            const sign = dx > 0 ? 1 : -1;
                            this.ball.x += overlap * sign;
                            this.ball.vx *= -0.8;
                        }
                    }
                });
                
                // Ball collision with obstacles
                this.obstacles.forEach(obstacle => {
                    const dx = this.ball.x - obstacle.x;
                    const dy = this.ball.y - obstacle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = this.ball.radius + obstacle.radius;
                    
                    if (distance < minDistance) {
                        // Collision response
                        const angle = Math.atan2(dy, dx);
                        const overlap = minDistance - distance;
                        
                        // Move ball out of obstacle
                        this.ball.x += Math.cos(angle) * overlap;
                        this.ball.y += Math.sin(angle) * overlap;
                        
                        // Reflect velocity
                        const normalX = dx / distance;
                        const normalY = dy / distance;
                        const dotProduct = this.ball.vx * normalX + this.ball.vy * normalY;
                        
                        this.ball.vx -= 2 * dotProduct * normalX;
                        this.ball.vy -= 2 * dotProduct * normalY;
                        
                        // Apply some energy loss
                        this.ball.vx *= 0.9;
                        this.ball.vy *= 0.9;
                    }
                });

                // Clamp ball within world bounds (edge walls) to prevent escaping path
                if (this.ball.x - this.ball.radius < 0) {
                    this.ball.x = this.ball.radius;
                    this.ball.vx *= -0.8;
                } else if (this.ball.x + this.ball.radius > this.worldWidth) {
                    this.ball.x = this.worldWidth - this.ball.radius;
                    this.ball.vx *= -0.8;
                }

                if (this.ball.y - this.ball.radius < 0) {
                    this.ball.y = this.ball.radius;
                    this.ball.vy *= -0.8;
                } else if (this.ball.y + this.ball.radius > this.worldHeight) {
                    this.ball.y = this.worldHeight - this.ball.radius;
                    this.ball.vy *= -0.8;
                }

                // Update viewport to follow the ball after physics & collisions
                this.updateViewport();

                // Check if ball is in hole
                const dx = this.ball.x - this.hole.x;
                const dy = this.ball.y - this.hole.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.hole.radius && Math.abs(this.ball.vx) < 2 && Math.abs(this.ball.vy) < 2) {
                    this.nextLevel();
                }
            }
            
            updateViewport() {
                // Always center viewport on the ball with no clamping – keeps ball at screen center
                this.viewport.x = this.ball.x - this.viewport.width / 2;
                this.viewport.y = this.ball.y - this.viewport.height / 2;
            }
            
            nextLevel() {
                this.level++;
                this.strokeCountElement.textContent = this.strokes = 0;
                this.levelCountElement.textContent = this.level;
                
                this.generateLevel();
            }
            
            draw() {
                // Fill entire viewport with wall color (#1C5D1D)
                this.ctx.fillStyle = '#1C5D1D';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Save context for viewport transformation
                this.ctx.save();
                this.ctx.translate(-this.viewport.x, -this.viewport.y);
                
                // Remove thick world borders (handled by grid walls)

                // Draw walkway/floor cells (#1C5D1D—same as wall per spec)
                this.ctx.fillStyle = '#1C5D1D';
                for (let r = 0; r < this.grid.length; r++) {
                    for (let c = 0; c < this.grid[0].length; c++) {
                        if (this.grid[r][c] === 1) {
                            this.ctx.fillRect(c * this.cellSize, r * this.cellSize, this.cellSize, this.cellSize);
                        }
                    }
                }

                // Draw perimeter outline between floor and wall tiles
                this.ctx.strokeStyle = '#55D04F';
                this.ctx.lineWidth = 8;
                this.ctx.lineJoin = 'round';
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                const rows = this.grid.length;
                const cols = this.grid[0].length;
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (this.grid[r][c] !== 1) continue; // only consider floor cell edges
                        const x = c * this.cellSize;
                        const y = r * this.cellSize;
                        // Top edge
                        if (r === 0 || this.grid[r - 1][c] === 0) {
                            this.ctx.moveTo(x, y);
                            this.ctx.lineTo(x + this.cellSize, y);
                        }
                        // Bottom edge
                        if (r === rows - 1 || this.grid[r + 1][c] === 0) {
                            this.ctx.moveTo(x, y + this.cellSize);
                            this.ctx.lineTo(x + this.cellSize, y + this.cellSize);
                        }
                        // Left edge
                        if (c === 0 || this.grid[r][c - 1] === 0) {
                            this.ctx.moveTo(x, y);
                            this.ctx.lineTo(x, y + this.cellSize);
                        }
                        // Right edge
                        if (c === cols - 1 || this.grid[r][c + 1] === 0) {
                            this.ctx.moveTo(x + this.cellSize, y);
                            this.ctx.lineTo(x + this.cellSize, y + this.cellSize);
                        }
                    }
                }
                this.ctx.stroke();
                
                // Draw obstacles
                this.obstacles.forEach(obstacle => {
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.beginPath();
                    this.ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Add some texture
                    this.ctx.strokeStyle = '#654321';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
                
                // Draw hole
                this.ctx.fillStyle = '#000000';
                this.ctx.beginPath();
                this.ctx.arc(this.hole.x, this.hole.y, this.hole.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw hole rim
                this.ctx.strokeStyle = '#333333';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // Draw ball
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add ball shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x + 2, this.ball.y + 2, this.ball.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw aim line when dragging
                if (this.isDragging) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.ball.x, this.ball.y);
                    this.ctx.lineTo(this.dragEnd.x, this.dragEnd.y);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Restore context
                this.ctx.restore();
                
                // Draw hole direction indicator if hole is off screen
                this.drawHoleIndicator();
            }
            
            drawHoleIndicator() {
                // Convert hole world position to screen position
                const holeScreenX = this.hole.x - this.viewport.x;
                const holeScreenY = this.hole.y - this.viewport.y;
                
                // Check if hole is off screen
                const margin = 50;
                const isOffScreen = holeScreenX < -margin || 
                                   holeScreenX > this.canvas.width + margin ||
                                   holeScreenY < -margin || 
                                   holeScreenY > this.canvas.height + margin;
                
                if (isOffScreen) {
                    // Calculate direction from ball to hole
                    const dx = this.hole.x - this.ball.x;
                    const dy = this.hole.y - this.ball.y;
                    const angle = Math.atan2(dy, dx);
                    
                    // Position indicator on screen edge based on angle
                    let indicatorX, indicatorY;
                    const edgeDistance = 30;
                    
                    // Calculate intersection with screen edges
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                    // Find intersection with screen edges
                    let intersectionX, intersectionY;
                    
                    if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {
                        // Intersects with left or right edge
                        if (Math.cos(angle) > 0) {
                            // Right edge
                            intersectionX = this.canvas.width - edgeDistance;
                            intersectionY = centerY + Math.tan(angle) * (intersectionX - centerX);
                        } else {
                            // Left edge
                            intersectionX = edgeDistance;
                            intersectionY = centerY + Math.tan(angle) * (intersectionX - centerX);
                        }
                    } else {
                        // Intersects with top or bottom edge
                        if (Math.sin(angle) > 0) {
                            // Bottom edge
                            intersectionY = this.canvas.height - edgeDistance;
                            intersectionX = centerX + (intersectionY - centerY) / Math.tan(angle);
                        } else {
                            // Top edge
                            intersectionY = edgeDistance;
                            intersectionX = centerX + (intersectionY - centerY) / Math.tan(angle);
                        }
                    }
                    
                    // Clamp to screen bounds
                    indicatorX = Math.max(edgeDistance, Math.min(this.canvas.width - edgeDistance, intersectionX));
                    indicatorY = Math.max(edgeDistance, Math.min(this.canvas.height - edgeDistance, intersectionY));
                    
                    // Draw arrow
                    this.ctx.fillStyle = '#FF0000';
                    this.ctx.strokeStyle = '#FFFFFF';
                    this.ctx.lineWidth = 3;
                    
                    // Draw arrow pointing in the direction of the hole
                    this.ctx.save();
                    this.ctx.translate(indicatorX, indicatorY);
                    this.ctx.rotate(angle);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(-15, -10);
                    this.ctx.lineTo(15, 0);
                    this.ctx.lineTo(-15, 10);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                }
            }
            
            gameLoop(currentTime = 0) {
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.draw();
                

                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new Hyperputt();
        });
    </script>
</body>
</html> 